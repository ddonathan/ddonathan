import ImageModule from "./index.js";
import { expectType, expectError } from "tsd";
const fs = require("fs");
const path = require("path");
import { docxtemplater_image_module_namespace } from "./index";
import childProcess from "child_process";

function getImage(tagValue: any, tagName: string) {
	expectType<string>(tagName);
	return fs.readFileSync(tagValue);
}
function getImageAsync(tagValue: any, tagName: string) {
	let result: Promise<Buffer> = new Promise(function (resolve) {
		resolve(fs.readFileSync(tagValue));
	});
	return result;
}

function getImageArrayBuffer() {
	return new ArrayBuffer(100);
}
function getSVGFallback(svg: string, sizepixel: number[]) {
	return fs.readFileSync("test.png");
}

function getSize(
	imgData: Buffer,
	data: any,
	tagValue: string,
	options: docxtemplater_image_module_namespace.SizeOptions
): [number, number] {
	expectType<string>(options.part.type);
	expectType<number>(options.part.containerWidth);
	return [200, 200];
}
function getSizeAsync(): Promise<[number, number]> {
	let result: Promise<[number, number]> = new Promise(function (resolve) {
		resolve([200, 200]);
	});
	return result;
}
new ImageModule({
	getImage,
	getSize,
});

new ImageModule({
	getImage: getImageArrayBuffer,
	getSize,
});

new ImageModule({
	getImage,
	getSize,
	centered: true,
	dpi: 12,
	getSVGFallback,
});

expectError(
	new ImageModule({
		getImage,
		getSize,
		centered: "yes",
	})
);

new ImageModule({
	getImage: getImageAsync,
	getSize: getSizeAsync,
	centered: true,
	dpi: 12,
	getSVGFallback,
});

const imageData: { [x: string]: string } = { xxx: "xxx" };

const async = true;

function resolveSoon(val: any): Promise<any> {
	return Promise.resolve(val);
}
function rejectSoon(val: any): Promise<any> {
	return Promise.reject();
}
const base64Image =
	"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAIAAAACUFjqAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4QIJBywfp3IOswAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAkUlEQVQY052PMQqDQBREZ1f/d1kUm3SxkeAF/FdIjpOcw2vpKcRWCwsRPMFPsaIQSIoMr5pXDGNUFd9j8TOn7kRW71fvO5HTq6qqtnWtzh20IqE3YXtL0zyKwAROQLQ5l/c9gHjfKK6wMZjADE6s49Dver4/smEAc2CuqgwAYI5jU9NcxhHEy60sni986H9+vwG1yDHfK1jitgAAAABJRU5ErkJggg==";

const base64svgimage =
	"data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjEwMCIgd2lkdGg9IjEwMCI+CiAgPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMyIgZmlsbD0icmVkIiAvPgo8L3N2Zz4g";

const ExifImage = require("exif").ExifImage;
function scaleWithExif(
	result: [number, number],
	image: string | Buffer
): Promise<[number, number]> {
	return new Promise(function (resolve) {
		if (typeof image === "string") {
			image = Buffer.from(image, "binary");
		}
		try {
			// eslint-disable-next-line no-new
			new ExifImage({ image }, function (error: any, exifData: any) {
				if (error) {
					resolve(result);
				} else {
					const image = exifData.image;
					const unit = image.ResolutionUnit;
					const res = image.XResolution;
					let scaleFactor = 1;
					if (unit === 1) {
						scaleFactor = 1;
					} else if (unit === 2) {
						// dots per inch conversion
						scaleFactor = 96 / res;
					} else if (unit === 3) {
						// cm to inch conversion + dots per inch conversion
						scaleFactor = 96 / res / 2.54;
					}
					resolve([result[0] * scaleFactor, result[1] * scaleFactor]);
				}
			});
		} catch (error) {
			resolve(result);
		}
	});
}

function base64Parser(dataURL: string) {
	const stringBase64 = dataURL.replace(
		/^data:image\/(png|jpg|svg|svg\+xml);base64,/,
		""
	);
	let binaryString;
	if (typeof window !== "undefined") {
		binaryString = window.atob(stringBase64);
	} else {
		binaryString = Buffer.from(stringBase64, "base64").toString("binary");
	}
	const len = binaryString.length;
	const bytes = new Uint8Array(len);
	for (let i = 0; i < len; i++) {
		const ascii = binaryString.charCodeAt(i);
		bytes[i] = ascii;
	}
	return bytes.buffer;
}

const parts = [];
let calls = 0;
const fnCalls = [];
const currentSections = [];
const filePaths = [];
let myTagName = "";
let svgSize = [100, 100];

let height = 0;
let width = 0;

function getImageSize(): [number, number] {
	return [1, 1];
}
const ddgLink = "https://ddg.gg";
// it root
new ImageModule({
	getImage,
	getSize,
	centered: false,
});

// it should work with centering
new ImageModule({
	getImage,
	getSize,
	centered: true,
});

// it should work with async and reject
new ImageModule({
	getImage(image, tagValue) {
		return rejectSoon(new Error(`Error for tag '${tagValue}'`));
	},
	getSize,
	centered: true,
});

// it should throw error when using array as value
new ImageModule({
	getImage(tagValue) {
		return tagValue;
	},
	getSize,
	centered: true,
});

// it should show error if using Promise in sync mode
new ImageModule({
	getImage() {
		return resolveSoon(base64Parser(base64Image));
	},
	getSize,
});

// it should work with webp image
new ImageModule({
	getImage(img) {
		const baseImg = fs.readFileSync(
			path.resolve(__dirname, `../examples/${img}`)
		);
		if (
			baseImg[0] === 82 &&
			baseImg[1] === 73 &&
			baseImg[2] === 70 &&
			baseImg[3] === 70
		) {
			return new Promise(function (resolve, reject) {
				const result = childProcess.spawnSync(
					"gm",
					["convert", "-", "-format", "png", "png:-"],
					{
						input: baseImg,
					}
				);
				if (result.status !== 0) {
					// eslint-disable-next-line no-console
					console.error(
						JSON.stringify({
							"result.stderr": result.stderr.toString(),
						})
					);
					reject(new Error("Error while executing graphicsmagick"));
				}
				// console.log(JSON.stringify({"result.stdout": result.stdout}));
				return resolve(Buffer.from(result.stdout));
			});
		}
		return baseImg;
	},
	getSize,
});

// it should work with auto resize
new ImageModule({
	getImage,
	getSize() {
		return [500, 555];
	},
});

// it should work with size in cm or inches
new ImageModule({
	getImage,
	getSize() {
		return ["2.54cm", "1in"];
	},
});

// it should work with size in emus
new ImageModule({
	getImage,
	getSize() {
		return ["457200emu", "914400emu"];
	},
});

// it should work with base64 data
new ImageModule({
	getImage(image) {
		return image;
	},
	getSize,
});

// it should work with base64 data async
new ImageModule({
	getSize() {
		return resolveSoon([300, 300]);
	},
	getImage() {
		return resolveSoon(base64Parser(base64Image));
	},
});

// it should work with svg sync and base64
new ImageModule({
	getSize(a, b, c, d) {
		if (d.svgSize) {
			svgSize = d.svgSize;
		}
		return [300, 300];
	},
	getImage() {
		return base64Parser(base64svgimage);
	},
});

// it should work with svg async and base64
new ImageModule({
	getSize(a, b, c, d) {
		if (d.svgSize) {
			svgSize = d.svgSize;
		}
		return resolveSoon([300, 300]);
	},
	getImage() {
		return resolveSoon(base64Parser(base64svgimage));
	},
});

// it should work async with two images
new ImageModule({
	getSize() {
		return resolveSoon([300, 300]);
	},
	getImage(tagValue, tagName) {
		myTagName = tagName;
		return resolveSoon(imageData[tagValue]);
	},
});

// it should work with docprid of 8 and 10
new ImageModule({
	getImage() {
		return base64Parser(base64Image);
	},
	getSize,
});

// it should work with angular expressions to set size
new ImageModule({
	getImage(tagValue) {
		if (tagValue.size && tagValue.data) {
			return imageData[tagValue.data];
		}
		return imageData[tagValue];
	},
	getSize(_, tagValue) {
		if (tagValue.size && tagValue.data) {
			return tagValue.size;
		}
		return [150, 150];
	},
});

// it should work with inline image without dropping text
new ImageModule({
	getSize() {
		return [200, 200];
	},
	getImage,
});

// it should be possible to set width to 100% in table
new ImageModule({
	getSize(a, b, c, d) {
		const width = d.part.containerWidth;
		if (width) {
			return [width, width];
		}
		return [100, 100];
	},
	getImage,
});

// it should work with centering
new ImageModule({
	centered: true,
	getImage,
	getSize(a, b, c, d) {
		const width = d.part.containerWidth;
		if (width) {
			return [width, width];
		}
		return [100, 100];
	},
});

// it should be possible to set width to 100% in footer
new ImageModule({
	getImage,
	getSize(a, b, c, d) {
		const filePath = d.options.filePath;
		filePaths.push(filePath);
		const width = d.part.containerWidth;
		if (width) {
			return [width, 100];
		}
		return [100, 100];
	},
});

// it should be possible to set width to 100% in document
new ImageModule({
	getImage,
	getSize(a, b, c, d) {
		const width = d.part.containerWidth;
		if (width) {
			return [width, width];
		}
		return [100, 100];
	},
});

// it should not regress without section
new ImageModule({
	getImage,
	getSize(a, b, c, d) {
		const width = d.part.containerWidth;
		const pct = 10 / 100;
		if (width) {
			return [Math.floor(width * pct), Math.floor(width * pct)];
		}
		return [100, 100];
	},
});

// it should not regress when using {%image} inside table
new ImageModule({
	getImage,
	getSize: getImageSize,
});

// it should work inside textbox for docx
new ImageModule({
	getImage,
	getSize(a, b, c, d) {
		calls++;
		const width = d.part.containerWidth;
		const height = d.part.containerHeight;
		if (width && height) {
			return [width, height];
		}
		return [100, 100];
	},
});

// it should work with tag in textbox with v:rect tag
new ImageModule({
	getImage,
	getSize(img, value, tagName, context) {
		const sizeOf = require("image-size");
		let b;
		if (typeof img === "string") {
			b = Buffer.from(img, "binary");
		}
		const sizeObj = sizeOf(b);
		const maxWidth = context.part.containerWidth;
		const maxHeight =
			context.part.containerHeight || context.part.containerWidth;

		const widthRatio = sizeObj.width / maxWidth;
		const heightRatio = sizeObj.height / maxHeight;
		if (widthRatio < 1 && heightRatio < 1) {
			/*
			 * Do not scale up images that are
			 * smaller than maxWidth,maxHeight
			 */
			return [sizeObj.width, sizeObj.height];
		}
		let finalWidth, finalHeight;
		if (widthRatio > heightRatio) {
			/*
			 * Width will be equal to maxWidth
			 * because width is the most "limiting"
			 */
			finalWidth = maxWidth;
			finalHeight = sizeObj.height / widthRatio;
		} else {
			/*
			 * Height will be equal to maxHeight
			 * because height is the most "limiting"
			 */
			finalHeight = maxHeight;
			finalWidth = sizeObj.width / heightRatio;
		}

		return [Math.round(finalWidth), Math.round(finalHeight)];
	},
});

// it should work inside multi column document
new ImageModule({
	getImage,
	getSize(a, b, c, d) {
		calls++;
		const width = d.part.containerWidth;
		let expectedWidth = 192;
		if (d.part.value === "image2") {
			expectedWidth = 384;
		}
		if (width) {
			return [width, width];
		}
		return [100, 100];
	},
});

// it should work calculate containerWidth/containerHeight even if section is defined on top of paragraph
new ImageModule({
	getImage(data) {
		return base64Parser(data);
	},
	getSize(a, b, c, d) {
		return [d.part.containerWidth, 500];
	},
});

// it should be possible to add some caption block
new ImageModule({
	getImage,
	getSize() {
		return [200, 200];
	},
	getProps() {
		return { caption: { text: "My custom <apple>" } };
	},
});

// it should work with inline
new ImageModule({
	getImage,
	getProps() {
		return { caption: { text: "My custom <apple>" } };
	},
	getSize() {
		return [200, 200];
	},
});

// it should work with two images
new ImageModule({
	getImage,
	getSize() {
		return [300, 300];
	},
	getProps() {
		return { caption: { text: "My custom <apple>" } };
	},
});

// it should work without caption
new ImageModule({
	getImage,
	getProps() {
		return null;
	},
	getSize() {
		return [200, 200];
	},
});

// it should work and remove the prefix
new ImageModule({
	getImage,
	getProps() {
		return {
			caption: {
				prefix: "",
				text: "My custom <apple>",
				pStyle: "Caption",
				align: "right",
			},
			pStyle: "Heading1",
		};
	},
	getSize() {
		return [200, 200];
	},
});

// it should be possible to change height for inline
new ImageModule({
	getImage,
	getProps() {
		return {
			caption: {
				prefix: "",
				text: "Foobar",
				height: 100,
			},
			pStyle: "Heading1",
		};
	},
	getSize() {
		return [200, 200];
	},
});

// it should work with docx and update description
new ImageModule({
	getProps(a, b, tagName) {
		return {
			name: `mypicture {%${tagName}}`,
			alt: 'some ";^>description',
		};
	},
	getImage,
	getSize,
});

// it should work in header of docx and keep current size using title property
new ImageModule({
	getImage,
	getSize(a, b, c, d) {
		const copy = { ...d.part };
		delete copy.expanded;
		parts.push(copy);
		if (d.part.width && d.part.height) {
			return [d.part.width, d.part.height];
		}
		return [100, 100];
	},
});

// it should work with pptx using name property with multiple w:ext
new ImageModule({
	getImage,
	getSize(a, b, c, d) {
		if (d.part.width && d.part.height) {
			return [d.part.width, d.part.height];
		}
		return [100, 100];
	},
});

// it should be possible to resize existing image and center it
new ImageModule({
	getProps(a, b, c, d) {
		const { part, sizePixel } = d;
		if (
			part.module ===
				"open-xml-templating/docxtemplater-replace-image-module" &&
			part.width &&
			part.height &&
			sizePixel
		) {
			return {
				offset: [
					part.width / 2 - sizePixel[0] / 2,
					part.height / 2 - sizePixel[1] / 2,
				],
			};
		}
	},
	getImage,
	getSize,
});

// it should be possible to move image
new ImageModule({
	getImage,
	getSize,
	getProps(a, b, c, d) {
		const { part, sizePixel } = d;
		if (
			part.module ===
				"open-xml-templating/docxtemplater-replace-image-module" &&
			part.width &&
			part.height &&
			sizePixel
		) {
			return {
				offset: [part.width / 2 - sizePixel[0] / 2, 0],
			};
		}
	},
});

// it should be possible to rotate image
new ImageModule({
	getImage,
	getSize,
	getProps(a, b, c, d) {
		const { part, sizePixel } = d;
		if (
			part.module ===
				"open-xml-templating/docxtemplater-replace-image-module" &&
			part.width &&
			part.height &&
			sizePixel
		) {
			return {
				rotation: 180,
			};
		}
	},
});

// it should be possible to flip image
new ImageModule({
	getImage,
	getSize,
	getProps(a, b, c, d) {
		const { part, sizePixel } = d;
		if (
			part.module ===
				"open-xml-templating/docxtemplater-replace-image-module" &&
			part.width &&
			part.height &&
			sizePixel
		) {
			return {
				flipVertical: true,
				flipHorizontal: true,
			};
		}
	},
});

// it should be possible to add link to existing image for pptx
new ImageModule({
	getImage,
	getSize,
	getProps() {
		return {
			link: ddgLink,
		};
	},
});

// it should be possible to add link to existing image for docx
new ImageModule({
	getProps() {
		return {
			link: ddgLink,
		};
	},
	getImage,
	getSize,
});

// it should be possible to left align image
new ImageModule({
	getImage,
	getProps() {
		return { align: "left" };
	},
	getSize() {
		return [200, 200];
	},
});

// it should be possible to right align image
new ImageModule({
	getImage,
	getProps() {
		return { align: "right" };
	},
	getSize() {
		return [200, 200];
	},
});

// it should fail if the shape has other text inside it
new ImageModule({
	getSize,
	getImage() {
		return base64Parser(base64Image);
	},
});

// it should fail with centered if text inside paragraph
new ImageModule({
	getSize() {
		return [300, 300];
	},
	getImage() {
		return base64Parser(base64svgimage);
	},
	centered: true,
});

// it should be possible to declare svg fallback to transform SVG to png
new ImageModule({
	getSize() {
		return resolveSoon([50, 50]);
	},
	getSVGFallback(svgFile, sizePixel) {
		return new Promise(function (resolve, reject) {
			const result = childProcess.spawnSync(
				"gm",
				["convert", "SVG:-", "-resize", sizePixel.join("x"), "PNG:-"],
				{
					input: Buffer.from(svgFile),
				}
			);
			if (result.status !== 0) {
				/* eslint-disable-next-line no-console */
				console.error(
					JSON.stringify({
						"result.stderr": result.stderr.toString(),
					})
				);
				reject(new Error("Error while executing graphicsmagick"));
			}
			return resolve(Buffer.from(result.stdout));
		});
	},
	getImage() {
		return resolveSoon(base64Parser(base64svgimage));
	},
});

// it should be possible to declare svg fallback to transform SVG to png
new ImageModule({
	getSize() {
		return resolveSoon([50, 50]);
	},
	getImage() {
		return resolveSoon(base64Parser(base64svgimage));
	},
});

// it should be possible to change dpi
new ImageModule({
	getSize(image) {
		const sizeOf = require("image-size");
		if (typeof image === "string") {
			const buffer = Buffer.from(image, "binary");
			const sizeObj = sizeOf(buffer);
			if (sizeObj.width && sizeObj.height) {
				return scaleWithExif([sizeObj.width, sizeObj.height], image);
			}
		}
		throw new Error("Error");
	},
	getImage(tagValue) {
		return resolveSoon(imageData[tagValue]);
	},
});

// it should be possible to set name and alt text
new ImageModule({
	getImage,
	getProps() {
		return { name: "mypicture", alt: 'some ";^>description' };
	},
	getSize() {
		return [200, 200];
	},
});

// it should work
new ImageModule({
	getImage,
	getProps() {
		return { link: ddgLink };
	},
	getSize() {
		return [200, 200];
	},
});

// it should work vertically
new ImageModule({
	getImage,
	getProps() {
		return { flipVertical: true };
	},
	getSize() {
		return [200, 200];
	},
});

// it should work horizontally
new ImageModule({
	getImage,
	getProps() {
		return { flipHorizontal: true };
	},
	getSize() {
		return [200, 200];
	},
});

// it should work
new ImageModule({
	getImage,
	getProps() {
		return { rotation: 90 };
	},
	getSize() {
		return [200, 200];
	},
});

// it should work with images-inside-cols
new ImageModule({
	getImage(data) {
		return base64Parser(data);
	},
	getSize(a, b, c, d) {
		return [d.part.containerWidth, 100];
	},
});

// it should work with image-table background
new ImageModule({
	getImage,
	getSize: getImageSize,
	getProps() {
		return {
			imageFit: "fill",
		};
	},
});
