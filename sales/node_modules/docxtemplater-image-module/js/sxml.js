"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var _require = require("./attributes.js"),
  setSingleAttribute = _require.setSingleAttribute,
  getSingleAttribute = _require.getSingleAttribute;
var pushArray = require("./push-array.js");
function canonicalizeState(state) {
  if (state.xml) {
    var _state$iUpdates, _state$iIndex;
    (_state$iUpdates = state.iUpdates) !== null && _state$iUpdates !== void 0 ? _state$iUpdates : state.iUpdates = [];
    (_state$iIndex = state.iIndex) !== null && _state$iIndex !== void 0 ? _state$iIndex : state.iIndex = 0;
    if (state.iUpdates.length > 0) {
      for (var i = state.iIndex; i < state.iUpdates.length; i++) {
        var update = state.iUpdates[i];
        var _update = _slicedToArray(update, 2),
          index = _update[0],
          length = _update[1];
        if (state.index[0] > index) {
          state.index[0] += length;
        }
        if (state.index[1] >= index) {
          state.index[1] += length;
        }
      }
      state.iIndex = state.iUpdates.length;
    }
    if (state.index[0] < 0 || state.index[1] > state.xml.length) {
      throw new Error("invalid state : [".concat(state.index[0], ", ").concat(state.index[1], "], length: ").concat(state.xml.length));
    }
    return state;
  }
  if (state instanceof Array) {
    return {
      xml: state,
      index: [0, state.length],
      iUpdates: [],
      iIndex: 0
    };
  }
}
function findParent(state, tagName) {
  state = canonicalizeState(state);
  var leftIndex = -1;
  var rightIndex = -1;
  for (var i = state.index[0]; i >= 0; i--) {
    if (state.xml[i].tag === tagName && state.xml[i].position === "start") {
      leftIndex = i;
      break;
    }
  }
  for (var _i2 = state.index[1]; _i2 < state.xml.length; _i2++) {
    if (state.xml[_i2].tag === tagName && state.xml[_i2].position === "end") {
      rightIndex = _i2;
      break;
    }
  }
  if (leftIndex === -1 || rightIndex === -1) {
    return null;
  }
  return _objectSpread(_objectSpread({}, state), {}, {
    index: [leftIndex, rightIndex]
  });
}
function getText(state) {
  state = canonicalizeState(state);
  var text = "";
  for (var i = state.index[0], len = state.index[1]; i < len; i++) {
    var part = state.xml[i];
    if (part.type === "tag") {
      continue;
    }
    if (part.type === "content") {
      text += part.value;
    }
  }
  return text;
}
function getAttribute(state, attribute) {
  state = canonicalizeState(state);
  return getSingleAttribute(state.xml[state.index[0]].value, attribute);
}
function setAttribute(state, attribute, value) {
  if (_typeof(attribute) === "object") {
    Object.keys(attribute).forEach(function (attr) {
      setAttribute(state, attr, attribute[attr]);
    });
    return;
  }
  if (typeof value === "function") {
    var currentValue = getSingleAttribute(state.xml[state.index[0]].value, attribute);
    var valueFn = value;
    value = valueFn(currentValue);
  }
  state = canonicalizeState(state);
  state.xml[state.index[0]].value = setSingleAttribute(state.xml[state.index[0]].value, attribute, value);
}
function findChilds(state, tagName) {
  var first = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  state = canonicalizeState(state);
  if (tagName instanceof Array) {
    var _childs = [state];
    tagName.forEach(function (tagName) {
      var subchilds = _childs.map(function (child) {
        return findChilds(child, tagName);
      });
      _childs = [];
      subchilds.forEach(function (subchild) {
        pushArray(_childs, subchild);
      });
    });
    if (first) {
      return _childs[0];
    }
    return _childs;
  }
  var childs = [];
  var startChild = null;
  for (var i = state.index[0], len = state.index[1]; i < len; i++) {
    var part = state.xml[i];
    if (part.tag === tagName && part.position === "start") {
      startChild = i;
    }
    if (part.tag === tagName && part.position === "end") {
      childs.push(_objectSpread(_objectSpread({}, state), {}, {
        index: [startChild, i]
      }));
      if (first) {
        return childs[0];
      }
    }
    if (part.tag === tagName && part.position === "selfclosing") {
      childs.push(_objectSpread(_objectSpread({}, state), {}, {
        index: [i, i]
      }));
      if (first) {
        return childs[0];
      }
    }
  }
  if (first) {
    return null;
  }
  return childs;
}
function findDirectChilds(state, tagName) {
  var first = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  state = canonicalizeState(state);
  var childs = [];
  var startChild = null;
  var level = 0;
  for (var i = state.index[0], len = state.index[1]; i < len; i++) {
    var part = state.xml[i];
    if (part.position === "start" || part.position === "selfclosing") {
      level++;
    }
    if (level === 2 && part.tag === tagName) {
      if (part.position === "start") {
        startChild = i;
      }
      if (part.position === "end") {
        childs.push(_objectSpread(_objectSpread({}, state), {}, {
          index: [startChild, i]
        }));
        if (first) {
          return childs[0];
        }
      }
      if (part.position === "selfclosing") {
        childs.push(_objectSpread(_objectSpread({}, state), {}, {
          index: [i, i]
        }));
        if (first) {
          return childs[0];
        }
      }
    }
    if (part.position === "end" || part.position === "selfclosing") {
      level--;
    }
  }
  if (first) {
    return null;
  }
  return childs;
}
function firstDirectChild(state, tagName) {
  return findDirectChilds(state, tagName, true);
}
function firstDirectChildOrCreate(state, tagName) {
  var tag = firstDirectChild(state, tagName);
  if (tag === null) {
    appendChild(state, [selfClosing(tagName)]);
    tag = firstDirectChild(state, tagName);
  }
  return tag;
}
function firstChild(state, tagName) {
  return findChilds(state, tagName, true);
}
function getContent(state) {
  var content = "";
  for (var i = state.index[0] + 1, len = state.index[1]; i < len; i++) {
    var part = state.xml[i];
    if (part.type === "content") {
      content += part.value;
    }
  }
  return content;
}
function dropChildren(state) {
  var length = state.index[1] - 1 - state.index[0];
  xmlsplice(state, state.index[0] + 1, length);
}
function xmlsplice(state, index, drop) {
  var _state$xml;
  var xml = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  (_state$xml = state.xml).splice.apply(_state$xml, [index, drop].concat(_toConsumableArray(xml)));
  state.iUpdates.push([index, -drop + xml.length]);
}
function dropSelf(state) {
  var length = state.index[1] + 1 - state.index[0];
  xmlsplice(state, state.index[0], length);
}
function replaceSelf(state, newXML) {
  state = canonicalizeState(state);
  if (!newXML) {
    throw new Error("Invalid call to replaceSelf");
  }
  xmlsplice(state, state.index[0], state.index[1] + 1 - state.index[0], newXML);
}
function replaceChildren(state, newXML) {
  state = canonicalizeState(state);
  if (!newXML) {
    throw new Error("Invalid call to replaceChildren");
  }
  xmlsplice(state, state.index[0] + 1, state.index[1] - 1 - state.index[0], newXML);
}
function selfClosing(name) {
  return {
    type: "tag",
    value: "<".concat(name, "/>"),
    position: "selfclosing",
    tag: name
  };
}
function create(tagName, attributes, child) {
  var startValue = "<".concat(tagName, ">");
  Object.keys(attributes).forEach(function (attribute) {
    startValue = setSingleAttribute(startValue, attribute, attributes[attribute]);
  });
  var childXml = [];
  if (child != null && _typeof(child) === "object") {
    childXml = child.xml;
  }
  if (typeof child === "string") {
    childXml = [{
      type: "content",
      value: child
    }];
  }
  if (typeof child === "number") {
    childXml = [{
      type: "content",
      value: child.toString()
    }];
  }
  return canonicalizeState([{
    type: "tag",
    position: "start",
    value: startValue,
    tag: tagName
  }].concat(childXml).concat([{
    type: "tag",
    position: "end",
    tag: tagName,
    value: "</".concat(tagName, ">")
  }]));
}
function insertAfter(element1, element2) {
  element1 = canonicalizeState(element1);
  element2 = canonicalizeState(element2);
  var lastIndex = element1.index[1];
  xmlsplice(element1, lastIndex + 1, 0, element2.xml);
  return element1;
}
function insertBefore(element1, element2) {
  element1 = canonicalizeState(element1);
  element2 = canonicalizeState(element2);
  var firstIndex = element1.index[0];
  xmlsplice(element1, firstIndex, 0, element2.xml);
  return element1;
}
function appendChild(parent, child) {
  var _parent$xml;
  parent = canonicalizeState(parent);
  child = canonicalizeState(child);
  var firstIndex = parent.index[0];
  var selfclosing = false;
  var tag = parent.xml[firstIndex].tag;
  var val = parent.xml[firstIndex].value;
  var index = parent.index[1];
  if (parent.xml[firstIndex].position === "selfclosing") {
    selfclosing = true;
    var lastChar = val[val.length - 1];
    if (lastChar === ">" && val[val.length - 2] === "/") {
      parent.xml[firstIndex].position = "start";
      parent.xml[firstIndex].value = parent.xml[firstIndex].value.substr(0, val.length - 2) + ">";
    }
    index++;
  }
  var newXml = child.xml.concat(selfclosing ? [{
    value: "</".concat(tag, ">"),
    type: "tag",
    position: "end",
    tag: tag
  }] : []);
  var length = newXml.length;
  (_parent$xml = parent.xml).splice.apply(_parent$xml, [index, 0].concat(_toConsumableArray(newXml)));
  parent.iUpdates.push([parent.index[1], length]);
  return parent;
}
function getIndent(indent) {
  var str = "";
  for (var i = 0, len = indent; i < len; i++) {
    str += "  ";
  }
  return str;
}
function xml2string(state) {
  var shouldIndent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var str = "";
  state = canonicalizeState(state);
  var indent = 0;
  if (state.index[0] === -1) {
    throw new Error("Invalid state");
  }
  for (var i = state.index[0]; i < state.index[1]; i++) {
    var part = state.xml[i];
    if (part.position === "end") {
      indent--;
    }
    if (shouldIndent) {
      str += getIndent(indent);
    }
    if (part.type === "delimiter") {
      switch (part.position) {
        case "start":
          str += "{";
          break;
        case "end":
          str += "}";
          break;
      }
    } else if (part.module) {
      str += "[[".concat(part.module.toUpperCase(), ":").concat(part.value, "]]");
    } else {
      str += part.value;
    }
    if (shouldIndent) {
      str += "\n";
    }
    if (part.position === "start") {
      indent++;
    }
  }
  return str;
}
function toString(state) {
  state = canonicalizeState(state);
  if (state.index[0] === -1) {
    throw new Error("Invalid state");
  }
  var text = "";
  for (var i = state.index[0]; i < state.index[1]; i++) {
    var part = state.xml[i];
    text += part.value;
  }
  return text;
}
module.exports = {
  getAttribute: getAttribute,
  toString: toString,
  setAttribute: setAttribute,
  findParent: findParent,
  findChilds: findChilds,
  xml2string: xml2string,
  create: create,
  appendChild: appendChild,
  firstChild: firstChild,
  firstDirectChild: firstDirectChild,
  firstDirectChildOrCreate: firstDirectChildOrCreate,
  findDirectChilds: findDirectChilds,
  insertAfter: insertAfter,
  insertBefore: insertBefore,
  getContent: getContent,
  dropChildren: dropChildren,
  dropSelf: dropSelf,
  replaceChildren: replaceChildren,
  replaceSelf: replaceSelf,
  canonicalizeState: canonicalizeState,
  selfClosing: selfClosing,
  getText: getText
};